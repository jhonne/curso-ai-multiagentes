#!/usr/bin/env python3
"""
Exerc√≠cio 3: Testes e Monitoramento
Pratique cria√ß√£o de testes unit√°rios e sistemas de monitoramento
"""

import unittest
from dotenv import load_dotenv
from crewai import Agent, Task, Crew
import time

load_dotenv()


class ExercicioTestes(unittest.TestCase):
    """
    EXERC√çCIO 3A: Crie testes unit√°rios para agentes

    TAREFA:
    1. Complete os m√©todos de teste abaixo
    2. Crie pelo menos 3 casos de teste diferentes
    3. Teste configura√ß√µes espec√≠ficas de agentes
    4. Valide resultados esperados
    """

    def setUp(self):
        """Configura√ß√£o inicial para testes"""
        # TODO: Crie um agente para testes
        self.agente_teste = None

    def test_configuracao_agente(self):
        """TODO: Teste se o agente foi configurado corretamente"""
        # TODO: Verificar role, goal, backstory
        self.fail("Teste n√£o implementado")

    def test_resposta_sentimento_positivo(self):
        """TODO: Teste classifica√ß√£o de sentimento positivo"""
        # TODO: Usar feedback positivo e verificar classifica√ß√£o
        self.fail("Teste n√£o implementado")

    def test_resposta_sentimento_negativo(self):
        """TODO: Teste classifica√ß√£o de sentimento negativo"""
        # TODO: Usar feedback negativo e verificar classifica√ß√£o
        self.fail("Teste n√£o implementado")

    def test_tempo_resposta(self):
        """TODO: Teste se resposta √© gerada em tempo aceit√°vel"""
        # TODO: Verificar se execu√ß√£o leva menos de 30 segundos
        self.fail("Teste n√£o implementado")


def exercicio_3b_sistema_monitoramento():
    """
    EXERC√çCIO 3B: Implemente sistema de monitoramento

    TAREFA:
    1. Crie classe para monitorar execu√ß√µes de agentes
    2. Registre m√©tricas: tempo, tokens, sucessos/falhas
    3. Gere relat√≥rios de performance
    4. Implemente alertas para problemas
    """

    print("üèãÔ∏è EXERC√çCIO 3B: Sistema de Monitoramento")
    print("=" * 50)

    class MonitorAgente:
        """TODO: Implemente sistema de monitoramento"""

        def __init__(self):
            # TODO: Inicializar estruturas de dados para m√©tricas
            pass

        def registrar_execucao(self, agente_id, tempo, tokens, sucesso):
            """TODO: Registrar m√©tricas de uma execu√ß√£o"""
            pass

        def gerar_relatorio(self):
            """TODO: Gerar relat√≥rio de performance"""
            pass

        def verificar_alertas(self):
            """TODO: Verificar se h√° problemas que precisam de alerta"""
            pass

    # TODO: Teste o sistema de monitoramento
    print("‚ùå EXERC√çCIO N√ÉO IMPLEMENTADO")
    print("üí° DICA: Use dicion√°rios para armazenar m√©tricas por agente")


def exercicio_3c_cache_inteligente():
    """
    EXERC√çCIO 3C: Implemente cache para otimizar custos

    TAREFA:
    1. Crie sistema de cache que armazena respostas similares
    2. Implemente fun√ß√£o de hash para prompts
    3. Adicione TTL (time to live) para entradas
    4. Monitore taxa de acerto do cache
    """

    print("\nüèãÔ∏è EXERC√çCIO 3C: Cache Inteligente")
    print("=" * 40)

    class CacheInteligente:
        """TODO: Implemente sistema de cache"""

        def __init__(self, ttl_segundos=3600):
            # TODO: Inicializar cache com TTL
            pass

        def get(self, prompt):
            """TODO: Buscar resposta no cache"""
            pass

        def set(self, prompt, resposta):
            """TODO: Armazenar resposta no cache"""
            pass

        def estatisticas(self):
            """TODO: Retornar estat√≠sticas do cache"""
            pass

    # TODO: Teste o sistema de cache
    print("‚ùå EXERC√çCIO N√ÉO IMPLEMENTADO")
    print("üí° DICA: Use hash() para criar chaves √∫nicas dos prompts")


# ============================================================================
# SOLU√á√ïES DE EXEMPLO
# ============================================================================


class SolucaoTestes(unittest.TestCase):
    """SOLU√á√ÉO do Exerc√≠cio 3A"""

    def setUp(self):
        """Configura√ß√£o inicial para testes"""
        self.agente_teste = Agent(
            role="Classificador de Sentimento",
            goal="Classificar sentimento de feedback como POSITIVO, NEGATIVO ou NEUTRO",
            backstory="""
            Voc√™ √© um especialista em an√°lise de sentimento.
            Responda APENAS com: POSITIVO, NEGATIVO ou NEUTRO.
            """,
            verbose=False,
            llm_config={
                "model": "gpt-3.5-turbo",
                "temperature": 0.0,  # Zero para m√°xima consist√™ncia
                "max_tokens": 10,  # Apenas uma palavra
            },
        )

    def test_configuracao_agente(self):
        """Testa configura√ß√£o do agente"""
        self.assertEqual(self.agente_teste.role, "Classificador de Sentimento")
        self.assertIn("sentimento", self.agente_teste.goal.lower())
        self.assertEqual(self.agente_teste.llm_config["temperature"], 0.0)

    def test_resposta_sentimento_positivo(self):
        """Testa classifica√ß√£o positiva"""
        feedback = "Produto excelente! Superou todas as expectativas!"

        task = Task(
            description=f"Classifique: {feedback}",
            expected_output="POSITIVO, NEGATIVO ou NEUTRO",
            agent=self.agente_teste,
        )

        crew = Crew(agents=[self.agente_teste], tasks=[task], verbose=False)

        try:
            resultado = crew.kickoff()
            self.assertIn("POSITIVO", str(resultado).upper())
        except Exception as e:
            self.fail(f"Erro na execu√ß√£o: {e}")

    def test_resposta_sentimento_negativo(self):
        """Testa classifica√ß√£o negativa"""
        feedback = "Produto terr√≠vel! N√£o funcionou nem um dia!"

        task = Task(
            description=f"Classifique: {feedback}",
            expected_output="POSITIVO, NEGATIVO ou NEUTRO",
            agent=self.agente_teste,
        )

        crew = Crew(agents=[self.agente_teste], tasks=[task], verbose=False)

        try:
            resultado = crew.kickoff()
            self.assertIn("NEGATIVO", str(resultado).upper())
        except Exception as e:
            self.fail(f"Erro na execu√ß√£o: {e}")

    def test_tempo_resposta(self):
        """Testa tempo de resposta"""
        feedback = "Produto ok, nada demais"

        task = Task(
            description=f"Classifique: {feedback}",
            expected_output="POSITIVO, NEGATIVO ou NEUTRO",
            agent=self.agente_teste,
        )

        crew = Crew(agents=[self.agente_teste], tasks=[task], verbose=False)

        start_time = time.time()
        try:
            crew.kickoff()
            tempo_execucao = time.time() - start_time
            self.assertLess(tempo_execucao, 30.0, "Resposta demorou mais que 30s")
        except Exception as e:
            self.fail(f"Erro na execu√ß√£o: {e}")


def solucao_exercicio_3b():
    """SOLU√á√ÉO do Exerc√≠cio 3B"""

    print("‚úÖ SOLU√á√ÉO 3B: Sistema de Monitoramento")
    print("=" * 50)

    from collections import defaultdict
    from datetime import datetime

    class MonitorAgente:
        """Sistema completo de monitoramento"""

        def __init__(self):
            self.metricas = defaultdict(list)
            self.alertas = []
            self.inicio = datetime.now()

        def registrar_execucao(self, agente_id, tempo, tokens, sucesso, erro=None):
            """Registra m√©tricas de execu√ß√£o"""
            registro = {
                "timestamp": datetime.now(),
                "tempo": tempo,
                "tokens": tokens,
                "sucesso": sucesso,
                "erro": erro,
            }

            self.metricas[agente_id].append(registro)

            # Verifica alertas
            if tempo > 30:
                self.alertas.append(f"‚ö†Ô∏è {agente_id}: Tempo alto ({tempo:.1f}s)")
            if tokens > 2000:
                self.alertas.append(f"‚ö†Ô∏è {agente_id}: Muitos tokens ({tokens})")
            if not sucesso:
                self.alertas.append(f"üö® {agente_id}: Falha - {erro}")

        def gerar_relatorio(self):
            """Gera relat√≥rio completo"""
            relatorio = []
            relatorio.append("üìä RELAT√ìRIO DE MONITORAMENTO")
            relatorio.append("=" * 40)

            for agente_id, registros in self.metricas.items():
                if not registros:
                    continue

                sucessos = sum(1 for r in registros if r["sucesso"])
                tempos = [r["tempo"] for r in registros]
                tokens = [r["tokens"] for r in registros]

                relatorio.append(f"\nü§ñ {agente_id}:")
                relatorio.append(f"   Execu√ß√µes: {len(registros)}")
                relatorio.append(
                    f"   Sucessos: {sucessos}/{len(registros)} ({sucessos/len(registros)*100:.1f}%)"
                )
                relatorio.append(f"   Tempo m√©dio: {sum(tempos)/len(tempos):.2f}s")
                relatorio.append(f"   Tokens total: {sum(tokens)}")
                relatorio.append(f"   Custo estimado: ${sum(tokens) * 0.002:.4f}")

            if self.alertas:
                relatorio.append(f"\nüö® ALERTAS ({len(self.alertas)}):")
                for alerta in self.alertas[-5:]:  # √öltimos 5
                    relatorio.append(f"   {alerta}")

            return "\n".join(relatorio)

    # Demonstra√ß√£o
    monitor = MonitorAgente()

    # Simula algumas execu√ß√µes
    execucoes = [
        ("agente_rapido", 2.5, 150, True, None),
        ("agente_lento", 35.0, 800, True, None),  # Gera alerta de tempo
        ("agente_gastao", 5.0, 2500, True, None),  # Gera alerta de tokens
        ("agente_problema", 10.0, 300, False, "API Error"),  # Gera alerta de falha
    ]

    for agente_id, tempo, tokens, sucesso, erro in execucoes:
        monitor.registrar_execucao(agente_id, tempo, tokens, sucesso, erro)

    print(monitor.gerar_relatorio())


def main():
    """Fun√ß√£o principal"""
    print("üèãÔ∏è EXERC√çCIO 3: TESTES E MONITORAMENTO")
    print("=" * 70)

    print("üìã EXERC√çCIOS PARA COMPLETAR:")
    print("3A. Crie testes unit√°rios para agentes")
    print("3B. Implemente sistema de monitoramento")
    print("3C. Crie cache inteligente para otimiza√ß√£o")
    print()

    # Executa testes (inicialmente falham)
    print("üß™ Executando testes de exerc√≠cio (v√£o falhar at√© serem implementados):")
    suite = unittest.TestLoader().loadTestsFromTestCase(ExercicioTestes)
    runner = unittest.TextTestRunner(verbosity=1)
    resultado = runner.run(suite)

    # Exerc√≠cios de monitoramento
    exercicio_3b_sistema_monitoramento()
    exercicio_3c_cache_inteligente()

    print("\n" + "=" * 70)
    print("üîç QUER VER AS SOLU√á√ïES? Execute:")
    print("python -m unittest __main__.SolucaoTestes -v  # Para testes")
    print("# solucao_exercicio_3b()  # Para monitoramento")

    # Descomente para ver solu√ß√µes:
    # print("\n" + "="*50)
    # solucao_exercicio_3b()

    print("\nüéØ M√âTRICAS IMPORTANTES PARA MONITORAR:")
    print("‚Ä¢ ‚è±Ô∏è Tempo de execu√ß√£o por agente")
    print("‚Ä¢ üî§ Uso de tokens e custos associados")
    print("‚Ä¢ ‚úÖ Taxa de sucesso das execu√ß√µes")
    print("‚Ä¢ üö® Padr√µes de falhas e erros")
    print("‚Ä¢ üìà Tend√™ncias de performance ao longo do tempo")

    print("\nüí° BENEF√çCIOS DO MONITORAMENTO:")
    print("‚Ä¢ Identifica√ß√£o proativa de problemas")
    print("‚Ä¢ Otimiza√ß√£o de custos com tokens")
    print("‚Ä¢ Melhoria cont√≠nua da performance")
    print("‚Ä¢ Dados para tomada de decis√µes")


if __name__ == "__main__":
    main()
